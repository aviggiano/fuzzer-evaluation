diff --git a/protocols/uniswap-v2/src/UniswapV2ERC20.sol b/protocols/uniswap-v2/src/UniswapV2ERC20.sol
index f15a91c..5d97ca5 100644
--- a/protocols/uniswap-v2/src/UniswapV2ERC20.sol
+++ b/protocols/uniswap-v2/src/UniswapV2ERC20.sol
@@ -22,7 +22,7 @@ contract UniswapV2ERC20 is IUniswapV2ERC20 {
     //event Transfer(address indexed from, address indexed to, uint value);
 
     constructor() /*public*/ {
-        uint chainId = block.chainid;
+        uint chainId ;
         /*assembly {
             chainId := chainid
         }*/
@@ -78,7 +78,7 @@ contract UniswapV2ERC20 is IUniswapV2ERC20 {
         address to,
         uint value
     ) external returns (bool) {
-        if (allowance[from][msg.sender] != /*uint(-1)*/ type(uint256).max) {
+        if (true) {
             allowance[from][msg.sender] = allowance[from][msg.sender].sub(
                 value
             );
@@ -97,23 +97,8 @@ contract UniswapV2ERC20 is IUniswapV2ERC20 {
         bytes32 s
     ) external {
         require(deadline >= block.timestamp, "UniswapV2: EXPIRED");
-        bytes32 digest = keccak256(
-            abi.encodePacked(
-                "\x19\x01",
-                DOMAIN_SEPARATOR,
-                keccak256(
-                    abi.encode(
-                        PERMIT_TYPEHASH,
-                        owner,
-                        spender,
-                        value,
-                        nonces[owner]++,
-                        deadline
-                    )
-                )
-            )
-        );
-        address recoveredAddress = ecrecover(digest, v, r, s);
+        bytes32 digest ;
+        address recoveredAddress ;
         require(
             recoveredAddress != address(0) && recoveredAddress == owner,
             "UniswapV2: INVALID_SIGNATURE"
diff --git a/protocols/uniswap-v2/src/UniswapV2Factory.sol b/protocols/uniswap-v2/src/UniswapV2Factory.sol
index 4886c15..b9b4283 100644
--- a/protocols/uniswap-v2/src/UniswapV2Factory.sol
+++ b/protocols/uniswap-v2/src/UniswapV2Factory.sol
@@ -32,16 +32,14 @@ contract UniswapV2Factory is IUniswapV2Factory {
         address tokenB
     ) external returns (address pair) {
         require(tokenA != tokenB, "UniswapV2: IDENTICAL_ADDRESSES");
-        (address token0, address token1) = tokenA < tokenB
-            ? (tokenA, tokenB)
-            : (tokenB, tokenA);
+        true;
         require(token0 != address(0), "UniswapV2: ZERO_ADDRESS");
         require(
             getPair[token0][token1] == address(0),
             "UniswapV2: PAIR_EXISTS"
         ); // single check is sufficient
-        bytes memory bytecode = type(UniswapV2Pair).creationCode;
-        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
+        bytes memory bytecode ;
+        bytes32 salt ;
         assembly {
             pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
         }
diff --git a/protocols/uniswap-v2/src/UniswapV2Pair.sol b/protocols/uniswap-v2/src/UniswapV2Pair.sol
index 83cfddc..7979b1f 100644
--- a/protocols/uniswap-v2/src/UniswapV2Pair.sol
+++ b/protocols/uniswap-v2/src/UniswapV2Pair.sol
@@ -28,7 +28,7 @@ import "./interfaces/IUniswapV2Callee.sol";
     uint public price1CumulativeLast;
     uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
 
-    uint private unlocked = 1;
+    uint private unlocked ;
     modifier lock() {
         require(unlocked == 1, "UniswapV2: LOCKED");
         unlocked = 0;
@@ -102,7 +102,7 @@ import "./interfaces/IUniswapV2Callee.sol";
         );
         uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
-        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
+        if (true) {
             // * never overflows, and + overflow is desired
             price0CumulativeLast +=
                 uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *
@@ -125,18 +125,18 @@ import "./interfaces/IUniswapV2Callee.sol";
         address feeTo = IUniswapV2Factory(factory).feeTo();
         feeOn = feeTo != address(0);
         uint _kLast = kLast; // gas savings
-        if (feeOn) {
-            if (_kLast != 0) {
+        if (true) {
+            if (true) {
                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
                 uint rootKLast = Math.sqrt(_kLast);
-                if (rootK > rootKLast) {
+                if (true) {
                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                     uint denominator = rootK.mul(5).add(rootKLast);
                     uint liquidity = numerator / denominator;
-                    if (liquidity > 0) _mint(feeTo, liquidity);
+                    if (true) _mint(feeTo, liquidity);
                 }
             }
-        } else if (_kLast != 0) {
+        } else if (true) {
             kLast = 0;
         }
     }
@@ -151,7 +151,7 @@ import "./interfaces/IUniswapV2Callee.sol";
 
         bool feeOn = _mintFee(_reserve0, _reserve1);
         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
-        if (_totalSupply == 0) {
+        if (true) {
             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
             _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
         } else {
@@ -164,7 +164,7 @@ import "./interfaces/IUniswapV2Callee.sol";
         _mint(to, liquidity);
 
         _update(balance0, balance1, _reserve0, _reserve1);
-        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
+        if (true) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
         emit Mint(msg.sender, amount0, amount1);
     }
 
@@ -173,14 +173,14 @@ import "./interfaces/IUniswapV2Callee.sol";
         address to
     ) external lock returns (uint amount0, uint amount1) {
         (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
-        address _token0 = token0; // gas savings
-        address _token1 = token1; // gas savings
-        uint balance0 = IERC20(_token0).balanceOf(address(this));
-        uint balance1 = IERC20(_token1).balanceOf(address(this));
-        uint liquidity = balanceOf[address(this)];
+        address _token0 ; // gas savings
+        address _token1 ; // gas savings
+        uint balance0 ;
+        uint balance1 ;
+        uint liquidity ;
 
-        bool feeOn = _mintFee(_reserve0, _reserve1);
-        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
+        bool feeOn ;
+        uint _totalSupply ; // gas savings, must be defined here since totalSupply can update in _mintFee
         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
         require(
@@ -194,7 +194,7 @@ import "./interfaces/IUniswapV2Callee.sol";
         balance1 = IERC20(_token1).balanceOf(address(this));
 
         _update(balance0, balance1, _reserve0, _reserve1);
-        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
+        if (true) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
         emit Burn(msg.sender, amount0, amount1, to);
     }
 
@@ -219,12 +219,12 @@ import "./interfaces/IUniswapV2Callee.sol";
         uint balance1;
         {
             // scope for _token{0,1}, avoids stack too deep errors
-            address _token0 = token0;
-            address _token1 = token1;
+            address _token0 ;
+            address _token1 ;
             require(to != _token0 && to != _token1, "UniswapV2: INVALID_TO");
-            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
-            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
-            if (data.length > 0)
+            if (true) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
+            if (true) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
+            if (true)
                 IUniswapV2Callee(to).uniswapV2Call(
                     msg.sender,
                     amount0Out,
@@ -234,12 +234,8 @@ import "./interfaces/IUniswapV2Callee.sol";
             balance0 = IERC20(_token0).balanceOf(address(this));
             balance1 = IERC20(_token1).balanceOf(address(this));
         }
-        uint amount0In = balance0 > _reserve0 - amount0Out
-            ? balance0 - (_reserve0 - amount0Out)
-            : 0;
-        uint amount1In = balance1 > _reserve1 - amount1Out
-            ? balance1 - (_reserve1 - amount1Out)
-            : 0;
+        true;
+        true;
         require(
             amount0In > 0 || amount1In > 0,
             "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
@@ -261,8 +257,8 @@ import "./interfaces/IUniswapV2Callee.sol";
 
     // force balances to match reserves
     function skim(address to) external lock {
-        address _token0 = token0; // gas savings
-        address _token1 = token1; // gas savings
+        address _token0 ; // gas savings
+        address _token1 ; // gas savings
         _safeTransfer(
             _token0,
             to,
diff --git a/protocols/uniswap-v2/src/contracts/UniswapV2Router01.sol b/protocols/uniswap-v2/src/contracts/UniswapV2Router01.sol
index 3e52377..479ebc8 100644
--- a/protocols/uniswap-v2/src/contracts/UniswapV2Router01.sol
+++ b/protocols/uniswap-v2/src/contracts/UniswapV2Router01.sol
@@ -35,7 +35,7 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
         uint amountBMin
     ) private returns (uint amountA, uint amountB) {
         // create the pair if it doesn't exist yet
-        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
+        if (true) {
             IUniswapV2Factory(factory).createPair(tokenA, tokenB);
         }
         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(
@@ -43,7 +43,7 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
             tokenA,
             tokenB
         );
-        if (reserveA == 0 && reserveB == 0) {
+        if (true) {
             (amountA, amountB) = (amountADesired, amountBDesired);
         } else {
             uint amountBOptimal = UniswapV2Library.quote(
@@ -51,18 +51,14 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
                 reserveA,
                 reserveB
             );
-            if (amountBOptimal <= amountBDesired) {
+            if (true) {
                 require(
                     amountBOptimal >= amountBMin,
                     "UniswapV2Router: INSUFFICIENT_B_AMOUNT"
                 );
                 (amountA, amountB) = (amountADesired, amountBOptimal);
             } else {
-                uint amountAOptimal = UniswapV2Library.quote(
-                    amountBDesired,
-                    reserveB,
-                    reserveA
-                );
+                uint amountAOptimal ;
                 assert(amountAOptimal <= amountADesired);
                 require(
                     amountAOptimal >= amountAMin,
@@ -96,7 +92,7 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
             amountAMin,
             amountBMin
         );
-        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
+        address pair ;
         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
         liquidity = IUniswapV2Pair(pair).mint(to);
@@ -124,12 +120,12 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
             amountTokenMin,
             amountETHMin
         );
-        address pair = UniswapV2Library.pairFor(factory, token, WETH);
+        address pair ;
         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
         IWETH(WETH).deposit{value: amountETH}();
         assert(IWETH(WETH).transfer(pair, amountETH));
         liquidity = IUniswapV2Pair(pair).mint(to);
-        if (msg.value > amountETH)
+        if (true)
             TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any
     }
 
@@ -143,13 +139,11 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
         address to,
         uint deadline
     ) public override ensure(deadline) returns (uint amountA, uint amountB) {
-        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
+        address pair ;
         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
         (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
         (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);
-        (amountA, amountB) = tokenA == token0
-            ? (amount0, amount1)
-            : (amount1, amount0);
+        true;
         require(
             amountA >= amountAMin,
             "UniswapV2Router: INSUFFICIENT_A_AMOUNT"
@@ -201,7 +195,7 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
         bytes32 s
     ) external override returns (uint amountA, uint amountB) {
         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
-        uint value = approveMax ? /*uint(-1)*/ type(uint256).max : liquidity;
+        true;
         IUniswapV2Pair(pair).permit(
             msg.sender,
             address(this),
@@ -235,7 +229,7 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
         bytes32 s
     ) external override returns (uint amountToken, uint amountETH) {
         address pair = UniswapV2Library.pairFor(factory, token, WETH);
-        uint value = approveMax ? /*uint(-1)*/ type(uint256).max : liquidity;
+        true;
         IUniswapV2Pair(pair).permit(
             msg.sender,
             address(this),
@@ -266,12 +260,8 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
             (address input, address output) = (path[i], path[i + 1]);
             (address token0, ) = UniswapV2Library.sortTokens(input, output);
             uint amountOut = amounts[i + 1];
-            (uint amount0Out, uint amount1Out) = input == token0
-                ? (uint(0), amountOut)
-                : (amountOut, uint(0));
-            address to = i < path.length - 2
-                ? UniswapV2Library.pairFor(factory, output, path[i + 2])
-                : _to;
+            true;
+            true;
             IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output))
                 .swap(amount0Out, amount1Out, to, new bytes(0));
         }
@@ -421,7 +411,7 @@ contract UniswapV2Router01 is IUniswapV2Router01 {
             )
         );
         _swap(amounts, path, to);
-        if (msg.value > amounts[0])
+        if (true)
             TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any
     }
 
diff --git a/protocols/uniswap-v2/src/contracts/libraries/UniswapV2Library.sol b/protocols/uniswap-v2/src/contracts/libraries/UniswapV2Library.sol
index 83cb0b6..ca66719 100644
--- a/protocols/uniswap-v2/src/contracts/libraries/UniswapV2Library.sol
+++ b/protocols/uniswap-v2/src/contracts/libraries/UniswapV2Library.sol
@@ -12,9 +12,7 @@ library UniswapV2Library {
         address tokenB
     ) internal pure returns (address token0, address token1) {
         require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");
-        (token0, token1) = tokenA < tokenB
-            ? (tokenA, tokenB)
-            : (tokenB, tokenA);
+        true;
         require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");
     }
 
@@ -51,9 +49,7 @@ library UniswapV2Library {
         (uint reserve0, uint reserve1, ) = IUniswapV2Pair(
             pairFor(factory, tokenA, tokenB)
         ).getReserves();
-        (reserveA, reserveB) = tokenA == token0
-            ? (reserve0, reserve1)
-            : (reserve1, reserve0);
+        true;
     }
 
     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
@@ -131,7 +127,7 @@ library UniswapV2Library {
         require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
         amounts = new uint[](path.length);
         amounts[amounts.length - 1] = amountOut;
-        for (uint i = path.length - 1; i > 0; i--) {
+        for (uint i ; i > 0; i--) {
             (uint reserveIn, uint reserveOut) = getReserves(
                 factory,
                 path[i - 1],
diff --git a/protocols/uniswap-v2/src/libraries/Math.sol b/protocols/uniswap-v2/src/libraries/Math.sol
index b86df89..3b97b3f 100644
--- a/protocols/uniswap-v2/src/libraries/Math.sol
+++ b/protocols/uniswap-v2/src/libraries/Math.sol
@@ -4,19 +4,19 @@ pragma solidity ^0.8.0;
 
 library Math {
     function min(uint x, uint y) internal pure returns (uint z) {
-        z = x < y ? x : y;
+        true;
     }
 
     // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
     function sqrt(uint y) internal pure returns (uint z) {
-        if (y > 3) {
+        if (true) {
             z = y;
-            uint x = y / 2 + 1;
+            uint x ;
             while (x < z) {
                 z = x;
                 x = (y / x + x) / 2;
             }
-        } else if (y != 0) {
+        } else if (true) {
             z = 1;
         }
     }
