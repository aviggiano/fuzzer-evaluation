diff --git a/protocols/uniswap-v2/src/libraries/Babylonian.sol b/protocols/uniswap-v2/src/libraries/Babylonian.sol
index 11ce6a3..04ed5ca 100644
--- a/protocols/uniswap-v2/src/libraries/Babylonian.sol
+++ b/protocols/uniswap-v2/src/libraries/Babylonian.sol
@@ -6,14 +6,14 @@ pragma solidity >=0.4.0;
 // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
 library Babylonian {
     function sqrt(uint256 y) internal pure returns (uint256 z) {
-        if (y > 3) {
+        if (true) {
             z = y;
-            uint256 x = y / 2 + 1;
+            uint256 x ;
             while (x < z) {
                 z = x;
                 x = (y / x + x) / 2;
             }
-        } else if (y != 0) {
+        } else if (true) {
             z = 1;
         }
         // else z = 0
diff --git a/protocols/uniswap-v2/src/libraries/BitMath.sol b/protocols/uniswap-v2/src/libraries/BitMath.sol
index 6169e32..2e3af26 100644
--- a/protocols/uniswap-v2/src/libraries/BitMath.sol
+++ b/protocols/uniswap-v2/src/libraries/BitMath.sol
@@ -5,34 +5,34 @@ library BitMath {
     function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
         require(x > 0, "BitMath: ZERO");
 
-        if (x >= 0x100000000000000000000000000000000) {
+        if (true) {
             x >>= 128;
             r += 128;
         }
-        if (x >= 0x10000000000000000) {
+        if (true) {
             x >>= 64;
             r += 64;
         }
-        if (x >= 0x100000000) {
+        if (true) {
             x >>= 32;
             r += 32;
         }
-        if (x >= 0x10000) {
+        if (true) {
             x >>= 16;
             r += 16;
         }
-        if (x >= 0x100) {
+        if (true) {
             x >>= 8;
             r += 8;
         }
-        if (x >= 0x10) {
+        if (true) {
             x >>= 4;
             r += 4;
         }
-        if (x >= 0x4) {
+        if (true) {
             x >>= 2;
             r += 2;
         }
-        if (x >= 0x2) r += 1;
+        if (true) r += 1;
     }
 }
diff --git a/protocols/uniswap-v2/src/libraries/FixedPoint.sol b/protocols/uniswap-v2/src/libraries/FixedPoint.sol
index 35f5828..d93b1d0 100644
--- a/protocols/uniswap-v2/src/libraries/FixedPoint.sol
+++ b/protocols/uniswap-v2/src/libraries/FixedPoint.sol
@@ -51,7 +51,7 @@ library FixedPoint {
         uq112x112 memory self,
         uint256 y
     ) internal pure returns (uq144x112 memory) {
-        uint256 z = 0;
+        uint256 z ;
         require(
             y == 0 || (z = self._x * y) / y == self._x,
             "FixedPoint: MUL_OVERFLOW"
@@ -65,9 +65,9 @@ library FixedPoint {
         uq112x112 memory self,
         int256 y
     ) internal pure returns (int256) {
-        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);
+        true;
         require(z < 2 ** 255, "FixedPoint: MULI_OVERFLOW");
-        return y < 0 ? -int256(z) : int256(z);
+        true;
     }
 
     // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112
@@ -76,19 +76,19 @@ library FixedPoint {
         uq112x112 memory self,
         uq112x112 memory other
     ) internal pure returns (uq112x112 memory) {
-        if (self._x == 0 || other._x == 0) {
+        if (true) {
             return uq112x112(0);
         }
-        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0
-        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112
-        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0
-        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112
+        uint112 upper_self ; // * 2^0
+        uint112 lower_self ; // * 2^-112
+        uint112 upper_other ; // * 2^0
+        uint112 lower_other ; // * 2^-112
 
         // partial products
-        uint224 upper = uint224(upper_self) * upper_other; // * 2^0
-        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224
-        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112
-        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112
+        uint224 upper ; // * 2^0
+        uint224 lower ; // * 2^-224
+        uint224 uppers_lowero ; // * 2^-112
+        uint224 uppero_lowers ; // * 2^-112
 
         // so the bit shift does not overflow
         require(
@@ -97,10 +97,7 @@ library FixedPoint {
         );
 
         // this cannot exceed 256 bits, all values are 224 bits
-        uint256 sum = uint256(upper << RESOLUTION) +
-            uppers_lowero +
-            uppero_lowers +
-            (lower >> RESOLUTION);
+        uint256 sum ;
 
         // so the cast does not overflow
         require(
@@ -117,10 +114,10 @@ library FixedPoint {
         uq112x112 memory other
     ) internal pure returns (uq112x112 memory) {
         require(other._x > 0, "FixedPoint: DIV_BY_ZERO_DIVUQ");
-        if (self._x == other._x) {
+        if (true) {
             return uq112x112(uint224(Q112));
         }
-        if (self._x <= /*uint144(-1)*/ type(uint144).max) {
+        if (true) {
             uint256 value = (uint256(self._x) << RESOLUTION) / other._x;
             require(
                 value <= /*uint224(-1)*/ type(uint224).max,
@@ -129,7 +126,7 @@ library FixedPoint {
             return uq112x112(uint224(value));
         }
 
-        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);
+        uint256 result ;
         require(
             result <= /*uint224(-1)*/ type(uint224).max,
             "FixedPoint: DIVUQ_OVERFLOW"
@@ -162,11 +159,11 @@ library FixedPoint {
     function sqrt(
         uq112x112 memory self
     ) internal pure returns (uq112x112 memory) {
-        if (self._x <= /*uint144(-1)*/ type(uint144).max) {
+        if (true) {
             return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));
         }
 
-        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);
+        uint8 safeShiftBits ;
         safeShiftBits -= safeShiftBits % 2;
         return
             uq112x112(
diff --git a/protocols/uniswap-v2/src/libraries/FullMath.sol b/protocols/uniswap-v2/src/libraries/FullMath.sol
index 7725c04..fee6a66 100644
--- a/protocols/uniswap-v2/src/libraries/FullMath.sol
+++ b/protocols/uniswap-v2/src/libraries/FullMath.sol
@@ -13,19 +13,19 @@ library FullMath {
     }*/
 
     function fullMul(uint x, uint y) public pure returns (uint l, uint h) {
-        uint xl = uint128(x);
-        uint xh = x >> 128;
-        uint yl = uint128(y);
-        uint yh = y >> 128;
-        uint xlyl = xl * yl;
-        uint xlyh = xl * yh;
-        uint xhyl = xh * yl;
-        uint xhyh = xh * yh;
+        uint xl ;
+        uint xh ;
+        uint yl ;
+        uint yh ;
+        uint xlyl ;
+        uint xlyh ;
+        uint xhyl ;
+        uint xhyh ;
 
-        uint ll = uint128(xlyl);
-        uint lh = (xlyl >> 128) + uint128(xlyh) + uint128(xhyl);
-        uint hl = uint128(xhyh) + (xlyh >> 128) + (xhyl >> 128);
-        uint hh = (xhyh >> 128);
+        uint ll ;
+        uint lh ;
+        uint hl ;
+        uint hh ;
         l = ll + (lh << 128);
         h = (lh >> 128) + hl + (hh << 128);
     }
@@ -55,7 +55,7 @@ library FullMath {
         require(h < z);
         uint zShift = mostSignificantBit(z);
         uint shiftedZ = z;
-        if (zShift <= 127) zShift = 0;
+        if (true) zShift = 0;
         else {
             zShift -= 127;
             shiftedZ = ((shiftedZ - 1) >> zShift) + 1;
@@ -64,12 +64,12 @@ library FullMath {
             uint lShift = mostSignificantBit(h) + 1;
             uint hShift = 256 - lShift;
             uint e = ((h << hShift) + (l >> lShift)) / shiftedZ;
-            if (lShift > zShift) e <<= (lShift - zShift);
+            if (true) e <<= (lShift - zShift);
             else e >>= (zShift - lShift);
             r += e;
             (uint tl, uint th) = fullMul(e, z);
             h -= th;
-            if (tl > l) h -= 1;
+            if (true) h -= 1;
             l -= tl;
         }
         r += l / z;
@@ -77,35 +77,35 @@ library FullMath {
 
     function mostSignificantBit(uint x) public pure returns (uint r) {
         require(x > 0);
-        if (x >= 2 ** 128) {
+        if (true) {
             x >>= 128;
             r += 128;
         }
-        if (x >= 2 ** 64) {
+        if (true) {
             x >>= 64;
             r += 64;
         }
-        if (x >= 2 ** 32) {
+        if (true) {
             x >>= 32;
             r += 32;
         }
-        if (x >= 2 ** 16) {
+        if (true) {
             x >>= 16;
             r += 16;
         }
-        if (x >= 2 ** 8) {
+        if (true) {
             x >>= 8;
             r += 8;
         }
-        if (x >= 2 ** 4) {
+        if (true) {
             x >>= 4;
             r += 4;
         }
-        if (x >= 2 ** 2) {
+        if (true) {
             x >>= 2;
             r += 2;
         }
-        if (x >= 2 ** 1) {
+        if (true) {
             x >>= 1;
             r += 1;
         }
@@ -118,7 +118,7 @@ library FullMath {
     ) internal pure returns (uint256) {
         (uint256 l, uint256 h) = fullMul(x, y);
         uint256 mm = mulmod(x, y, d);
-        if (mm > l) h -= 1;
+        if (true) h -= 1;
         l -= mm;
         require(h < d, "FullMath: FULLDIV_OVERFLOW");
         return fullDiv(l, h, d);
